# Задача 1. Hand-crafted graph features
## Задача

- [ ] Найти или сгенерировать набор данных для бинарной классификации графов.
- [ ] Реализовать функцию `shortest_path_kernel(train_graphs, test_graphs)`, которая принимает тренировочный и тестовые наборы, а возвращает пару `K_train, K_test`
  - Опишите графы с помощью вектора из количества кратчайших путей различной длины
  - Для вычисления длин кратчайших путей можно использовать `nx.shortest_path_length(G)`
  - Ядровая функция для сравнения двух графов - скалярное произведение их двух векторов
  - `K_train` - матрица из ядровых функций для сравнения тренировочных графов между собой
  - `K_test` - матрица из ядровых функций для сравнения тестовых графов с тренировочными
- [ ] Используя реализованное ядро обучите модель SVC, подберите гиперпараметры, вычислите различные метрики качества
- [ ] Также реализовать Weisfeiler-Lehman Kernel и обучить классификатор с ним, сравнить результаты.
      
# Задача 2. Node embeddings
## Задача
- [ ] Найти набор данных для бинарной классификации рёбер в графе.
- [ ] Реализовать случайные блуждания алгоритма `DeepWalk` и построить множества схожих вершин
- [ ] Обучить эмбеддинги вершин, используя `SGD` и **negative sampling**.
- [ ] Визуализировать эмбеддинги.
- [ ] Также реализовать `node2vec` блуждания и обучить классификатор, используя его. Сравнить результаты.

# Задача 3. Graph Convolutional Network
## Задача

- [ ] Найти графовый набор данных для решения задачи предсказания (классификация вершин, обнаружение сообществ и т.д.).
- [ ] Использовать несколько слоев `GCNConv` из библиотеки `PyG` для построения GCN модели.
- [ ] Обучить полученную модель, подобрать гиперпараметры (например, learning rate) на валидационной выборке, и оценить качество предсказания на тестовой выборке.
- [ ] Также представить самостоятельную реализацию слоя `GCNConv`, используя матричные операции. Повторить обучение с собственными слоями и сравнить результаты.
